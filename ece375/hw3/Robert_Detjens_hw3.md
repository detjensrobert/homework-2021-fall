# ECE 375 Homework 3

## Robert Detjens

---

### 1. Consider the `SHORTDELAY` subroutine that is outlined below. Write AVR assembly so that it utilizes the 16-bit Timer/Counter1 to delay for 201 milliseconds (0.201 seconds) Assume that the system clock frequency is 16 MHz.

```asm
.include "m128def.inc"
.def mpr = r16

; timer init value
; prescaler of 64 is smallest prescaler to result in 16 bit value
; 16 MHz = 16000 cycles / ms
; (16000 c/ms * 201ms) / 64 = 0xC44A
; but timer counts up, so actually need:
; 0xFFFF - 0xC44A = 0x3BB5
.def waitL = 0xB5
.def waitH = 0x3B

.ORG $0000
  RJMP Initialize
.ORG $0046    ; End of interrupt vectors
Initialize:
  ; set timer to normal mode
  ldi   mpr,      0
  out   TCCR1A,   mpr
  ldi   mpr,      0b00000011  ; clk/64 prescaling
  out   TCCR1B,   mpr
  ldi   mpr,      0
  out   TCCR1C,   mpr

SHORTDELAY:
  ; load timer with init value (this will start timer)
  ldi   mpr,      waitH
  out   TCNT1H,   mpr
  ldi   mpr,      waitL
  out   TCNT1L,   mpr

  wait_for_timer:
    ; check TOV1 bit in TIFR flag register
    in    mpr,      TIFR
    andi  mpr,      0b00000100
    breq  wait_for_timer  ; loop if not set

  ; clear overflow flag
  ldi   mpr,      0b00000100
  out   TIFR,     mpr

  RET
```

\pagebreak

### 2. Imagine that you want to program your lab board to handle the I/O configuration illustrated in the image below. Review the starter code that is provided below and fill in the missing lines (based on the instructions) to accomplish the given tasks. `mpr` is the only general purpose register that you are allowed to use in the code.

```asm
.include "m128def.inc"
.def mpr = r16

.org  $0000
  rjmp  INIT
.org  $000A
  rjmp HitRight
.org  $000C
  rjmp HitLeft

.org $0046
INIT:
  ; Configure direction of engine pins
  ldi   mpr,    0b00001111   ; set 0:3 as output
  out   DDRA,   mpr
  ldi   mpr,    $00   ; initially set to 0
  out   PORTA,  mpr

  ; Configure direction of bumper pins
  ldi   mpr,    $00   ; set all as input
  out   DDRE,   mpr

  ; Enable pull-up resisters for bumpers
  ldi   mpr,    $FF
  out   PORTE,  mpr

  ; Detect on falling edge
  ldi mpr, 0b10101010
  out EICRB, mpr

  ; Enable interrupts for bumpers
  ldi mpr, 0b11110000
  out EIMSK, mpr

  ; Turn on global interrupt
  sei
```

\pagebreak

### 3. Consider the AVR code segment shown below (with some missing information) that configures Timer/Counter0 for Fast PWM operation, and modifies the Fast PWM duty cycle whenever a specific button on Port D is pressed.

- Based on the prescale value used in part (a), what is the frequency of the PWM signal ($f_{PWM}$) being generated by
  Timer/Counter0? Assume the system clock frequency is 16 MHz.

  With prescaling of 8, the timer in PWM mode is generating a frequency $\frac{16 MHz}{8} = 2 MHz$

- What would be the value necessary for the variable step to increase the duty cycle by 12.5% each time the `DUTY_STEP`
  subroutine is executed?  Ignore the case when/if the compare value overflows.

  12.5% (1/8) of 0..255 is 32.

```asm
.include   "m128def.inc"
.def   mpr = r16
.def   temp = r17
.equ   step = 32

INIT:
  ; ...
  ; stack pointer is initialized
  ; ...

  ; I/O ports
  ldi   mpr, 0b00010000 ; set pin 4 (OC0) as output
  out   DDRB, mpr

  ldi   mpr, 0b00000000 ; set pin 0 as input
  out   DDRD, mpr
  ldi   mpr, 0b00000001 ; enable pull-up resistor for pin 0
  out   PORTD, mpr


  ; Timer/Counter0
  ; Fast PWM mode, non-inverting, prescale = 8
  ldi   mpr,    0b01101010  ; WGM01 | WGM00 | COM01 | CS01
  out   TCCR0,  mpr

  ; Initial compare value for PWM output
  ; 51% of 0..255 ~= 130
  ldi   mpr,    130
  out   OCR0,   mpr

MAIN:
  sbis    PIND, 0
  rcall   DUTY_STEP
  rjmp    MAIN


DUTY_STEP:
  push  mpr
  push  temp

  in    mpr,    OCR0  ; read the current PWM compare value
  ldi   temp,   step
  add   mpr,    temp  ; add step value to compare value
  out   OCR0,   mpr   ; write new PWM compare value


  pop   temp
  pop   mpr
  ret
```
